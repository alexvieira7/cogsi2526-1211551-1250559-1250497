 plugins {
    id 'org.springframework.boot' version '3.2.5'
    id 'io.spring.dependency-management' version '1.1.3'
    id 'java'
}

repositories {
    mavenLocal()
    maven {
        url = uri('https://repo.maven.apache.org/maven2/')
    }
}

dependencies {
    implementation 'org.springframework.boot:spring-boot-starter-web:3.2.5'
    implementation 'org.springframework.boot:spring-boot-starter-data-jpa:3.2.5'
    implementation 'org.springframework.boot:spring-boot-starter-hateoas:3.2.5'
    runtimeOnly 'com.h2database:h2:2.2.224'
    testImplementation 'org.springframework.boot:spring-boot-starter-test:3.2.5'
}

group = 'org.springframework.guides'
version = '0.0.1-SNAPSHOT'
description = 'rest'
java.sourceCompatibility = JavaVersion.VERSION_1_8

tasks.withType(JavaCompile) {
    options.encoding = 'UTF-8'
}

tasks.withType(Javadoc) {
    options.encoding = 'UTF-8'
}

tasks.register('deletePasta',Delete)
{
    delete(deployDir)
}

tasks.register('deployToDev') {
    group = 'deployment'
    description = 'Prepara pasta de deployment'
    dependsOn 'deletePasta',
    doLast {
        println "Deployment preparado em: ${deployDir.get().asFile}"
    }
}

tasks.register('runFromDist') {
    group = 'application'
    description = 'Instala a distribuição e executa a app a partir dos scripts gerados'
    dependsOn tasks.named('installDist')
    doLast {
        def base = file("$buildDir/install/${project.name}/bin")
        def isWindows = System.getProperty('os.name').toLowerCase().contains('win')
        def script = isWindows ? new File(base, "${project.name}.bat")
                               : new File(base, "${project.name}")
        if (!isWindows) script.setExecutable(true)
        println "A executar: ${script}"
        def p = new ProcessBuilder(script.absolutePath).inheritIO().start()
        p.waitFor()
    }
}

tasks.register('javadocZip', Zip) {
    group = 'documentation'
    description = 'Gera Javadoc e empacota em ZIP'
    dependsOn tasks.named('javadoc')
    from(tasks.named('javadoc').map { it.destinationDir })
    archiveBaseName.set("${project.name}-javadoc")
    destinationDirectory.set(layout.buildDirectory.dir("docs"))
}

tasks.register('copyApp', Copy) {
    dependsOn tasks.named('bootJar')
    from(tasks.named('bootJar').flatMap { it.archiveFile })
    into(deployDir)
}

tasks.register('copyRuntimeLibs', Copy) {
    from(configurations.runtimeClasspath)
    into(libsDir)
    include('**/*.jar')
}

tasks.register('copyConfigs', Copy) {
    from('src/main/resources') { include '*.properties' }
    into(deployDir)
    filter(ReplaceTokens, tokens: [
        version  : project.version.toString(),
        timestamp: new Date().format("yyyy-MM-dd'T'HH:mm:ss")
    ])
}

sourceSets {
    integrationTest {
        java {
            srcDir file('src/integrationTest/java')
        }
        resources.srcDir file('src/integrationTest/resources')
        compileClasspath += sourceSets.main.output + configurations.testRuntimeClasspath
        runtimeClasspath += output + compileClasspath
    }
}
configurations {
    integrationTestImplementation.extendsFrom testImplementation
    integrationTestRuntimeOnly.extendsFrom testRuntimeOnly
}

tasks.register('integrationTest', Test) {
    group = 'verification'
    description = 'Run integration test.'
    testClassesDirs = sourceSets.integrationTest.output.classesDirs
    classpath = sourceSets.integrationTest.runtimeClasspath
    shouldRunAfter test
    useJUnitPlatform()
}

tasks.check {
    dependsOn tasks.named("integrationTest")
}
